# تمرین شماره ۷

اعضای تیم:

- **امیرمحمد درخشنده**
- **کیان ایزدپناه**
- **مهدی حاجی‌بیگی**

# سوالات تئوری

در این بخش، به پاسخ‌دهی سوالات تئوری خواهیم پرداخت.

## سوال اول - مفاهیم اولیه

- **کد تمیز:** به طور کلی، هر کدی که از فهم و خوانایی بالایی برخوردار باشد و نگهداری آن آسان باشد، کد تمیز نامیده می‌شود. مواردی همچون ساختار منظم، نام‌بندی فایل های مناسب، نام متد های مرتب و مرتبط(به عنوان مثال استفاده از استاندارد CamelCase) می‌تواند همگی منجر به ساخت کد تمیز شود.

- **بدهی فنی:** به هنگام توسعه و پیاده‌سازی یک پروژه، تمامی مشکلات و ضعف ها(اعم از مشکلات ساختاری، فنی و کیفی) و یا انتخاب های نادرست به هنگام برنامه‌ریزی برای پروژه، بعد از آنکه جمع‌آوری بشوند، زمانی را بعدا باید برای حل آن‌ها و رفع‌شان اختصاص داد. به این میزان زمان، بدهی فنی می‌گویند.

- **بوی بد:** به مشکلاتی در ساختار پروژه(به طور عمده، مشکلاتی که در خود کد پروژه وجود دارد)، به طوری که می‌توانند منجر به بد شدن ساختار(فرضا در اتصال کد ها به هم و یا اتصال به دیتابیس)، سخت تر شدن نگهداری کد و ... شوند، بوی بد(بوی بد کد) می‌گویند.

## سوال دوم - دسته‌بندی Code smell ها

با بررسی محتوای سایت https://refactoring.guru/refactoring/smells، دسته بندی زیر برای انواع بوی بد ها وجود دارد:

- **Bloaters (بادکنکی‌ها):** کد های بادکنکی، کد هایی هستند که خیلی بزرگ یا پیچیده شده‌اند، به عنوان مثال، کد هایی که طولانی هستند، درک سختی دارند و یا پیچیدگی درک دارند، مدیریت، تغییر و نگهداری آن‌ها و استفاده در سایر قسمت ها از آن‌ها سخت تر می‌شود. به این نوع از بوی بد، Bloaters می‌گویند.

- **Object-Orientation Abusers (سوءاستفاده از شیءگرایی):** سوءاستفاده یا استفاده نادرست از مفاهیم شیءگرایی زمانی اتفاق می‌افتد که برنامه‌نویس از قابلیت‌هایی مانند وراثت، انتزاع یا الگوهای طراحی بدون نیاز واقعی یا به شکلی غلط استفاده کند که منجر به پیچیدگی غیرضروری و کاهش خوانایی کد می‌شود.

برای مثال، اگر یک کلاس فقط به خاطر داشتن چند ویژگی مشترک، از یک کلاس والد ارث‌بری کند، اما رفتار متفاوتی داشته باشد (وراثت نابجا)، این یک سوءاستفاده از شیءگرایی است.

به این نوع از بوی بد، Object-Orientation Abusers می‌گویند.

- **Change Preventers (جلوگیرها از تغییر):** به طور کلی، مشکلاتی که می‌توانند باعث جلوگیری از تغییر کد تحت شرایط لازم، Change Preventers می‌گویند. به عنوان مثال، وابستگی های زیاد بین متد ها و یا کلاس ها، می‌توانند همگی منجر به این مشکل بشوند و باید تا حد امکان، وابستگی های موجود را کم کرد.

- **Dispensables (اضافی‌ها):** بخش هایی که با حذف آن‌ها از کد، تغییری در کد اتفاق نمی‌اتفد، همگی Dispensables نامیده می‌شوند. به عنوان مثال، کد هایی که از آن‌ها هیچ کجا استفاده نمی‌شود(کد مرده)، توضیحات بیش از حد و یا تولیدات غیرضروری را می‌توان حذف کرد، به طوری که عملکرد کد تغییری نکند.

- **Couplers (جفت‌کننده‌ها):** به طور کلی، Couplers ها، وابستگی بیش از حد بین قسمت‌های مختلف کد (مثل وابستگی زیاد یک کلاس به کلاس دیگر)، که باعث کاهش انعطاف‌پذیری و تست‌پذیری می‌شود را شامل می‌شوند.

## سوال سوم - Feature Envy

- **این بوی بد در کدام دسته قرار می‌گیرد؟**

ابتدا به بررسی تعریف Feature Envy می‌پردازیم. این بوی بد، به طور کلی، زمانی رخ می‌دهد که یک متد یا کلاس، بیش از حد به داده‌ها یا متدهای کلاس دیگری علاقه نشان دهد و به جای کار کردن با داده‌های خودش، مدام سراغ اعضای کلاس‌های دیگر برود. به عبارتی، وابستگی بیش‌از حد به وجود می‌آورد، در نتیجه با توجه به تعاریفی که در پرسش دوم ارائه دادیم، این بوی بد در دسته Object-Orientation Abusers (سوء استفاده‌کنندگان از شیءگرایی) قرار می‌گیرد. شاید این سوال پیش بیاید با توجه به وابستگی بیش از اندازه، چرا این بوی بد در دسته پنجم قرار نمی‌گیرد. پاسخ آن است که تمرکز آن روی استفاده بیش از حد یک متد از داده‌ها یا متدهای کلاس دیگر است (یعنی به جای وابستگی ساختاری، علاقه بیش از حد عملکردی به اعضای یک کلاس دیگر دارد)، در دسته Object-Orientation Abusers قرار می‌گیرد، چون ایراد آن سوءاستفاده از شیءگرایی و اصل “هر شیء باید به داده‌های خودش دسترسی داشته باشد” است، نه لزوماً افزایش coupling (وابستگی بین کلاس‌ها).

به عبارت ساده تر:

- **Couplers:** وابستگی ساختاری و شدید بین کلاس‌ها (ارتباط نزدیک یا زنجیره‌ای).

- **Feature Envy:** سوء رفتار عملکردی متدها نسبت به داده‌های خارجی، که از اصول شیءگرایی خارج شده.

- **کدام روش بازآرایی برای این بوی بد، بهتر است؟**

- **Move Method (انتقال متد):** می‌توان متدی را که بیش از حد به داده‌ها یا متدهای یک کلاس دیگر وابسته است، به همان کلاس منتقل کرد.

- **Extract Method (استخراج متد):** اگر فقط بخشی از یک متد این بو را دارد، آن بخش را به متدی در کلاس مقصد، می‌توان منتقل کرد.

البته باید در نظر داشت که گاهی هم Inline Method یا Extract Class به صورت تکمیلی ممکن است مفید باشند (اگر منطق خیلی گسترده شد).

- **چه زمانی باید این بوی بد را نادیده گرفت؟**

اگر جابجایی متد باعث به هم خوردن نظم مسئولیت‌ها یا منطق کلی برنامه شود، انجام این بازآرایی پیشنهاد نمی‌شود، اما در مواردی که دسترسی متد به داده‌های کلاس دیگر بر اساس نیاز واقعی طراحی برنامه باشد، این وضعیت قابل قبول است. در چنین شرایطی، حذف این بو ممکن است مشکلات جدید ایجاد کند یا باعث به‌هم‌ریختگی بیشتر ساختار گردد، در نتیجه، وجود Feature Envy همیشه به معنای نیاز قطعی به بازآرایی نیست و باید با توجه به شرایط خاص پروژه تصمیم‌گیری شود.
